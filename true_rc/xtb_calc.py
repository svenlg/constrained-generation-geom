import os
import re
import numpy as np
import torch
import tempfile
import subprocess
from rdkit.Chem import GetPeriodicTable

import logging
from rdkit import RDLogger
RDLogger.DisableLog('rdApp.*')
logging.getLogger("rdkit").setLevel(logging.CRITICAL)

LOWEST_ALLOWED_ENERGY = -40
MAX_ALLOWED_ENERGY = 40

LOWEST_ALLOWED_DIPOLE = 0
MAX_ALLOWED_DIPOLE = 40

def extract_dipole(output: str, verbose: bool = True) -> float:
    """
    Extract the total dipole moment (Debye) from xTB output.
    Looks for the 'full:' line under 'molecular dipole'.
    """
    # Pattern: look for 'full:' followed by 3 floats (x, y, z) and then 1 float (total)
    pattern = re.compile(
        r"full:\s+"                # start of line
        r"([-+]?\d*\.\d+|\d+)\s+"  # x
        r"([-+]?\d*\.\d+|\d+)\s+"  # y
        r"([-+]?\d*\.\d+|\d+)\s+"  # z
        r"([-+]?\d*\.\d+|\d+)"     # total dipole
    )
    
    match = pattern.search(output)
    if not match:
        if verbose:
            print("Dipole not found in xTB output", flush=True)
        return 0
    
    # The last group is the total dipole in Debye
    dipole = float(match.group(4))
    if dipole < LOWEST_ALLOWED_DIPOLE or dipole > MAX_ALLOWED_DIPOLE:
        dipole = np.inf
    return float(dipole)

def extract_homo_lumo(output: str, verbose: bool = True) -> tuple:
    """
    Extract the HOMO-LUMO gap, LUMO, and HOMO energies from xTB output.
    """
    homo = None
    lumo = None
    for line in output.split("\n"):
        if "HOMO" in line:
            try:
                homo = float(line.split()[-2])
            except ValueError:
                return (None, None, None)
        elif "LUMO" in line:
            try:
                lumo = float(line.split()[-2])
            except ValueError:
                return (None, None, None)
        if (homo is not None) and (lumo is not None):
            return lumo - homo, lumo, homo
    if verbose: 
        if homo is None:
            print("HOMO not found in xTB output", flush=True)
        if lumo is None:
            print("LUMO not found in xTB output", flush=True)
    return (None, None, None)

def extract_energy(output: str, verbose: bool = True) -> float:
    for line in output.split("\n"):
        if "total energy" in line:
            try:
                energy = float(line.split()[-3])
                if energy < LOWEST_ALLOWED_ENERGY or energy > MAX_ALLOWED_ENERGY:
                    energy = np.inf
            except ValueError:
                energy = None
            return energy
    if verbose:
        print("Total energy not found in xTB output", flush=True)
    return None

def atomic_symbol(z: int) -> str:
    """Convert atomic number (int) to element symbol (str)."""
    pt = GetPeriodicTable()
    return pt.GetElementSymbol(int(z))

def molecule_to_xyz(molecule, format_type, filename="molecule.xyz"):
    """
    Convert a molecule from RDKit, DGL, or PyTorch Geometric format to an XYZ file.
    
    Args:
        molecule: The molecule object (RDKit Mol, DGLGraph, or PyTorch Geometric Data).
        format_type: The format of the molecule ("rdkit" or "dgl").
        filename: The output XYZ filename.
    """
    if format_type == "rdkit":
        # RDKit molecule
        atomic_numbers = [atom.GetAtomicNum() for atom in molecule.GetAtoms()]
        atomic_symbols = [atom.GetSymbol() for atom in molecule.GetAtoms()]
        positions = molecule.GetConformer().GetPositions()
    elif format_type == "dgl":
        # DGL graph
        atomic_numbers = torch.argmax(molecule.ndata['a_1'], dim=-1).numpy()
        atomic_symbols = [atomic_symbol(z) for z in atomic_numbers]
        positions = molecule.ndata['x_1'].numpy()
    else:
        raise ValueError("Unsupported format type. Use 'rdkit' or 'dgl'.")

    # Write to XYZ file
    with open(filename, "w") as f:
        f.write(f"{len(atomic_numbers)}\n")
        f.write("Generated by molecule_to_xyz\n")
        for symbol, pos in zip(atomic_symbols, positions):
            f.write(f"{symbol} {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n")

def run_xtb(xyz_file):
    """
    Run xtb on an XYZ file and extract the HOMO-LUMO gap, dipole and energy.
    """
    # Run xtb
    result = subprocess.run(["xtb", xyz_file], capture_output=True, text=True)
    output = result.stdout
    
    rtn_dict = {}
    # homolumo
    tmp = extract_homo_lumo(output)
    rtn_dict["homolumo_gap"] = tmp[0]
    rtn_dict["lumo"] = tmp[1]
    rtn_dict["homo"] = tmp[2]
    # dipole
    rtn_dict["dipole"] = extract_dipole(output)
    # energy
    rtn_dict["energy"] = extract_energy(output)

    return rtn_dict

def compute_xtb(molecule, format_type, verbose:bool = True):
    """
    Compute HOMO-LUMO gap, dipole, and energy for a molecule using xTB.
    Uses a unique temporary directory based on SLURM job ID (if available),
    otherwise falls back to the process ID.
    """
    # Get identifiers
    job_id = os.getenv("SLURM_JOB_ID")
    task_id = os.getenv("SLURM_ARRAY_TASK_ID")
    pid = os.getpid()

    # Build a prefix for the temp directory
    if job_id:
        prefix = f"xtb_{job_id}_{task_id or pid}_"
    else:
        prefix = f"xtb_{pid}_"

    with tempfile.TemporaryDirectory(prefix=prefix) as tmpdir:
        xyz_file = os.path.join(tmpdir, "molecule.xyz")
        molecule_to_xyz(molecule, format_type, xyz_file)

        # Run xTB inside the temp directory
        result = subprocess.run(
            ["xtb", xyz_file],
            cwd=tmpdir,
            capture_output=True,
            text=True,
        )
        output = result.stdout

        rtn_dict = {}
        gap, lumo, homo = extract_homo_lumo(output, verbose)
        rtn_dict["homolumo_gap"] = gap
        rtn_dict["lumo"] = lumo
        rtn_dict["homo"] = homo
        rtn_dict["dipole"] = extract_dipole(output, verbose)
        rtn_dict["energy"] = extract_energy(output, verbose)

        # TemporaryDirectory cleans up automatically
        return rtn_dict

